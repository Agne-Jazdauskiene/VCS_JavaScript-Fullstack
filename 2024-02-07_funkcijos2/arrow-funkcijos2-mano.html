<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    function rand(min, max) {
      min = Math.ceil(min);
      max = Math.floor(max);
      return Math.floor(Math.random() * (max - min + 1) + min);
    }




    // Jeigu atliekamas tik vienos eilutes veiksmas arrow funkcijoje riestiniai skliaustai
    // ir return komanda nera butina
    const divide = (pirma, antra) => pirma / antra;

    console.log(divide(10, 2));

    // I funkcija perduotu parametru patikrinimas

    const formatNumbers = (number) => {
      if (typeof number !== `number`)
        return;

      return number.toFixed(2);
    }

    console.log(formatNumbers());

    console.log(`Veikia`);

    // Callback (Atsisaukimo) principas

    // const formatavimas = (masyvas, callback) => {
    //   for (const reiksme of masyvas) {
    //     // for (const reiksme of masyvas)
    //     callback(reiksme);
    //   }
    // }

    // const masyvas = [5, 18, 20, 25, 8, 6];

    // formatavimas(masyvas, function (reiksme) {
    //   if (reiksme > 10) {
    //     document.write(`<p style="color:red;">${reiksme}</p>`);
    //   } else {
    //     document.write(`<p">${reiksme}</p>`);

    //   }
    // });

    // forEach() metodas. nieko negrazina. Skirtas tik prasukti cikla tiek, kiek masyve yra elementu

    const masyvas = [5, 18, 20, 25, 8, 6];
    // 5 * 0, 18*1, ir t.t.

    // forEach metodas nieko negrazina, neturi return

    // mes galime isvardinti parametrus tik eiles tvarka. galime tik viena parametra rasyti, jei kiti nereikalingi. jei tik indeksas reikalingas - butinai turime ivardinti ir pirmoj pozicijoj reiksme
    // eiles tvarka: element(reiksme), index, array(masyvas)

    masyvas.forEach(function (reiksme, indeksas, masyvas) {
      if (reiksme > 10) {
        document.write(`<p style="color:red;">${reiksme}</p>`);
      } else {
        document.write(`<p">${reiksme}</p>`);

      }
    });

    // PVZ UZDAVINYS
    // Suformuokite nauja masyva,pasinaudodami pirmuoju jo reiksmes padauginant is indekso

    // galime pasinaudoti array.prototype.map() metodu

    // seniau darydavome
    // const naujasMasyvas = [];
    // for (let i = 0; i < masyvas.length; i++) {
    //   naujasMasyvas.push(masyvas[i] * i);
    // }
    // console.log(naujasMasyvas);


    // map metodu
    // const naujasMasyvas = masyvas.map(function (reiksme, indeksas) {
    //   // console.log(reiksme, indeksas);
    //   return reiksme * indeksas;
    // });

    //arba ta pati  performuojam i viena eilute
    // map() metodas skirtas sugeneruoti nauja masyva callback funkcijoje nurodant reiksme
    const naujasMasyvas = masyvas.map(reiksme, indeksas => reiksme * indeksas);


    console.log(naujasMasyvas);

    // Suformuokite nauja masyva pasinaudodami pirmuoju palikdami tik reiksmes, kurios didesnes nei 10
    // Jeigu turime arrow funkcijoje priimame tik viena parametra, skliausteliai nebutini
    // filter() metodo callback funkcijoje nurodome true arba false atsakyma
    const filtruotasMasyvas = masyvas.filter(reiksme => reiksme > 10);

    console.log(filtruotasMasyvas.length);


    // Norint susirasti pirma masyvo reiksme, kuri yra didesne nei 10

    const ieskotasMasyvas = masyvas.find(reiksme => reiksme > 10);

    // reiksme didesne, nei 10
    console.log(ieskotasMasyvas);

    // Norintsusirasti pirma indeksa pagal kondicija

    const indeksas = masyvas.findIndex(reiksme => reiksme > 10);

    console.log(indeksas);


  </script>

</body>

</html>